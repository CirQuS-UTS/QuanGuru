

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Functions &mdash; Quantum Simulations 1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/jupyter-sphinx.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Evolutions" href="../Evolutions/evolutions.html" />
    <link rel="prev" title="Operators" href="../Operators/operators.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #051988" >
          

          
            <a href="../../index.html" class="icon icon-home"> Quantum Simulations
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../qTools.QuantumToolbox.html">QuantumToolbox</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../States/states.html">States</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Operators/operators.html">Operators</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Evolutions/evolutions.html">Evolutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Hamiltonians/hamiltonians.html">Hamiltonians</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Operations/operations.html">Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../QuasiProbabilities/quasiProbabilities.html">Quasi-Probabilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../CustomTypes/customTypes.html">Custom Types</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Quantum Simulations</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../qTools.QuantumToolbox.html">QuantumToolbox</a> &raquo;</li>
        
      <li>Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/QuantumToolbox/Functions/functions.rst" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="module-qTools.QuantumToolbox.functions">
<span id="functions"></span><h1>Functions<a class="headerlink" href="#module-qTools.QuantumToolbox.functions" title="Permalink to this headline">¶</a></h1>
<p>Module of functions to calculate expectations, fidelities, entropy etc. from quantum states</p>
<p>The reason for having several methods for the same task is to improve performance
For example, an if statement can be avoided using <cite>expectationMat/expectationKet</cite> for
<cite>density matrices/ket states</cite>, or
<cite>expectationKetList/expectationMatList</cite> is suitable in <cite>multi-processing</cite> of list of time-series of states</p>
<dl class="method">
<dt>
<code class="sig-name descname">:expectation : Function to calculate the expectation value of an `operator` for a given `state`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:expectationMat : Calculates the expectation value of an `operator` for a given `density matrix`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:expectationKet : Calculates the expectation value of an `operator` for a given `ket`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:expectationKetList : Calculates the expectation value of an `operator` for a given list of `ket` states</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:expectationMatList : Calculates the expectation value of an `operator` for a given list of `density matrices`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:expectationColArr : Calculates the expectation values of an `operator` for a list/matrix of `ket (column) states`</code></dt>
<dd><p>by matrix multiplication</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:fidelity : Calculates `fidelity` between `two states`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:fidelityKet : Calculates `fidelity` between two `ket` states</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:fidelityPureMat : Calculates `fidelity` between two (pure) `density matrices`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:fidelityKetList : Calculates `fidelity` between `a ket state` and `list of ket states`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:fidelityKetLists : Created to be used in `multi-processing` calculations of two lists of kets states</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:entropy : Calculates the `entropy` of a given `density matrix`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:entropyKet : Calculates the `entropy` of a given `ket` state</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:iprKet : Calculates the inverse participation ratio (a delocalisation measure) of a `ket` in a given basis</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:iprKetList : Calculates the inverse participation ratio (a delocalisation measure) of a `list of ket` states in a given basis</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:iprKetNB : Calculates the inverse participation ratio (a delocalisation measure) of a ket</code></dt>
<dd><p>by assuming that the basis is of the free Hamiltonian</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:iprKetNBList : Calculates the inverse participation ratio (a delocalisation measure) of a list kets</code></dt>
<dd><p>by assuming that the basis is of the free Hamiltonian</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:iprKetNBmat : Calculates the inverse participation ratio (a delocalisation measure) of `a matrix of ket states as the column`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:iprPureDenMat : Calculates the inverse participation ratio (a delocalisation measure) of a `density matrix` in a given `basis`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:sortedEigens : Calculates the `eigenvalues and eigenvectors` of a given Hamiltonian and `sorts` them</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:eigVecStatKet : Calculates components of a `ket` in a basis</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:eigVecStatKetList : Calculates components of a `list of ket states`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:eigVecStatKetNB : Calculates the components of a ket by assuming that the basis is of the free Hamiltonian</code></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.eigVecStatKet">
<code class="sig-name descname">eigVecStatKet</code><span class="sig-paren">(</span><em class="sig-param">basis: List[Matrix], ket: Matrix</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#eigVecStatKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.eigVecStatKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates components of a <cite>ket</cite> in a basis</p>
<p>Main use is in eigenvector statistics.</p>
<p>:param :
:type : param <cite>basis</cite> : a complete basis
:param :
:type : param <cite>ket</cite> : the ket state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>list</cite> of component values in the basis</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">completeBasis</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">components</span> <span class="o">=</span> <span class="n">eigVecStatKet</span><span class="p">(</span><span class="n">basis</span><span class="o">=</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">ket</span><span class="o">=</span><span class="n">ket</span><span class="p">)</span>
<span class="go">[0, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.eigVecStatKetList">
<code class="sig-name descname">eigVecStatKetList</code><span class="sig-paren">(</span><em class="sig-param">basis: List[Matrix], kets: List[Matrix]</em><span class="sig-paren">)</span> &#x2192; List[List[float]]<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#eigVecStatKetList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.eigVecStatKetList" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates components of a <cite>list of ket states</cite>
Main use is in eigenvector statistics.</p>
<p>:param :
:type : param <cite>basis</cite> : a complete basis
:param :
:type : param <cite>kets</cite> : <cite>list</cite> of ket states</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>list</cite> of component values in the basis</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ketList</span> <span class="o">=</span> <span class="p">[</span><span class="n">ket0</span><span class="p">,</span> <span class="n">ket1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">completeBasis</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">components</span> <span class="o">=</span> <span class="n">eigVecStatKetList</span><span class="p">(</span><span class="n">basis</span><span class="o">=</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">kets</span><span class="o">=</span><span class="n">ketList</span><span class="p">)</span>
<span class="go">[[1, 0], [0, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.eigVecStatKetNB">
<code class="sig-name descname">eigVecStatKetNB</code><span class="sig-paren">(</span><em class="sig-param">ket: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#eigVecStatKetNB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.eigVecStatKetNB" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the components of a ket by assuming that the basis is of the free Hamiltonian</p>
<p>:param :
:type : param <cite>ket</cite>: a ket state or list of ket states</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>return</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of components</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">completeBasis</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">components</span> <span class="o">=</span> <span class="n">eigVecStatKetNB</span><span class="p">(</span><span class="n">ket</span><span class="o">=</span><span class="n">ket</span><span class="p">)</span>
<span class="go">[0 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.entropy">
<code class="sig-name descname">entropy</code><span class="sig-paren">(</span><em class="sig-param">densMat: Matrix</em>, <em class="sig-param">base2: bool = False</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the <cite>entropy</cite> of a given <cite>density matrix</cite></p>
<p>Input should be a density matrix by definition of entropy.
Uses exponential basis as default.</p>
<p>:param :
:type : param <cite>densMat</cite>: a density matrix
:param :
:type : param <cite>base2</cite>: option to calculate in base 2</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: the <cite>entropy</cite> of the given <cite>density matrix</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compositeStateKet</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">compositeState</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropyKet</span> <span class="o">=</span> <span class="n">entropyKet</span><span class="p">(</span><span class="n">compositeStateKet</span><span class="p">)</span>
<span class="go">-0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compositeStateMat</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">compositeStateKet</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropyMat</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">compositeStateMat</span><span class="p">)</span>
<span class="go">-0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stateFirstSystem</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">compositeStateKet</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy1</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">stateFirstSystem</span><span class="p">)</span>
<span class="go">-0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stateSecondSystem</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">compositeStateKet</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy2</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">stateSecondSystem</span><span class="p">)</span>
<span class="go">-0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entangledKet</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="n">qStates</span><span class="o">.</span><span class="n">compositeState</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">+ qStates.compositeState(dimensions=[2, 2], excitations=[1,0], sparse=True))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropyKetEntangled</span> <span class="o">=</span> <span class="n">entropyKet</span><span class="p">(</span><span class="n">entangledKet</span><span class="p">)</span>
<span class="go">2.2204460492503126e-16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entangledMat</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">entangledKet</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropyMatEntangled</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">entangledMat</span><span class="p">)</span>
<span class="go">2.2204460492503126e-16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stateFirstSystemEntangled</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">entangledKet</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy1Entangled</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">stateFirstSystemEntangled</span><span class="p">)</span>
<span class="go">0.6931471805599454</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stateSecondSystemEntangled</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">entangledMat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy2Entangled</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">stateSecondSystemEntangled</span><span class="p">)</span>
<span class="go">0.6931471805599454</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.entropyKet">
<code class="sig-name descname">entropyKet</code><span class="sig-paren">(</span><em class="sig-param">ket: Matrix</em>, <em class="sig-param">base2: bool = False</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#entropyKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.entropyKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the <cite>entropy</cite> of a given <cite>ket</cite> state</p>
<p>This function should not exist at all, ket is always a pure state.</p>
<p>Input should be a density matrix by definition of entropy.
Uses exponential basis as default.</p>
<p>:param :
:type : param <cite>ket</cite> : a ket state
:param :
:type : param <cite>base2</cite> : option to calculate in base 2</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: the <cite>entropy</cite> of the given <cite>density matrix</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compositeStateKet</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">compositeState</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropyKet</span> <span class="o">=</span> <span class="n">entropyKet</span><span class="p">(</span><span class="n">compositeStateKet</span><span class="p">)</span>
<span class="go">-0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entangledKet</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="n">qStates</span><span class="o">.</span><span class="n">compositeState</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">+ qStates.compositeState(dimensions=[2, 2], excitations=[1,0], sparse=True))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropyKetEntangled</span> <span class="o">=</span> <span class="n">entropyKet</span><span class="p">(</span><span class="n">entangledKet</span><span class="p">)</span>
<span class="go">2.2204460492503126e-16</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.expectation">
<code class="sig-name descname">expectation</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix</em>, <em class="sig-param">state: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#expectation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to calculate the expectation value of an <cite>operator</cite> for a given <cite>state</cite></p>
<p>State can either be a <cite>ket</cite> or <cite>density matrix</cite>.
Operator has to be the matrix (sparse or not), cannot pass a reference to operator function from the toolbox.
State and operator can both be sparse or array or any combination of the two.</p>
<p>:param :
:type : param <cite>operator</cite> : matrix of a Hermitian operator
:param :
:type : param <cite>state</cite> : a quantum state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: expectation value of the <cite>operator</cite> for the <cite>state</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.operators</span> <span class="k">as</span> <span class="nn">qOperators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">ket</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectMat</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">denMat</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">ket1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">ket2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">denMat1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">denMat2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.expectationColArr">
<code class="sig-name descname">expectationColArr</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix</em>, <em class="sig-param">states: numpy.ndarray</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#expectationColArr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.expectationColArr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation values of an <cite>operator</cite> for a list/matrix of <cite>ket (column) states</cite> by matrix multiplication</p>
<p>The <cite>list</cite> here is effectively a matrix whose columns are <cite>ket</cite> states for which we want the expectation values.
For example, the eigenstates obtained from eigenvalue calculations of numpy or scipy are this form.
TODO introduced to be used with eigenvectors, needs to be tested for non-mutually orthogonal states.
So, it relies on states being orthonormal, if not there will be off-diagonal elements in the resultant matrix,
but still the diagonal elements are the expectation values, meaning it should work!</p>
<p>:param :
:type : param <cite>operator</cite> : matrix of a Hermitian operator
:param :
:type : param <cite>states</cite> : ket states as the columns in the input matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>list</cite> of expectation values of the <cite>operator</cite> for a matrix of <cite>ket</cite> states</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.operators</span> <span class="k">as</span> <span class="nn">qOperators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ham</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigVals</span><span class="p">,</span> <span class="n">eigVecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">ham</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sz</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sx</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectZ</span> <span class="o">=</span> <span class="n">expectationColArr</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">eigVecs</span><span class="p">)</span>
<span class="go">[ 1. -1.]</span>
<span class="go">&gt;&gt;&gt;&gt; expectX = expectationColArr(sx, eigVecs)</span>
<span class="go">[0. 0.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.expectationKet">
<code class="sig-name descname">expectationKet</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix</em>, <em class="sig-param">ket: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#expectationKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.expectationKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value of an <cite>operator</cite> for a given <cite>ket</cite></p>
<p>Calculates the density matrix and calls the expectationMat.
Computationally the same as using (bra &#64; operator &#64; ket).
Works with both sparse and array.
Operator has to be the matrix (sparse or not), cannot pass a reference to operator function from the toolbox.</p>
<p>:param :
:type : param <cite>operator</cite> : matrix of a Hermitian operator
:param :
:type : param <cite>ket</cite> : ket state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: expectation value of the <cite>operator</cite> for the <cite>ket</cite> state</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.operators</span> <span class="k">as</span> <span class="nn">qOperators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">ket</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">ket1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">ket2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.expectationKetList">
<code class="sig-name descname">expectationKetList</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix, kets: List[Matrix]</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#expectationKetList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.expectationKetList" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value of an <cite>operator</cite> for a given list of <cite>ket</cite> states</p>
<p>Simply calls the <cite>expectationKet</cite> in a loop.
This function exist for easy use in multi-processing.</p>
<p>:param :
:type : param <cite>operator</cite>: matrix of a Hermitian operator
:param :
:type : param <cite>kets</cite> : list of ket states</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>list</cite> of expectation values of the <cite>operator</cite> for the list of <cite>ket</cite> states</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ketList</span> <span class="o">=</span> <span class="p">[</span><span class="n">ket0</span><span class="p">,</span> <span class="n">ket1</span><span class="p">,</span> <span class="n">ket2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKetList</span> <span class="o">=</span> <span class="n">expectationKetList</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">kets</span><span class="o">=</span><span class="n">ketList</span><span class="p">)</span>
<span class="go">[-1, 1, 0.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.expectationMat">
<code class="sig-name descname">expectationMat</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix</em>, <em class="sig-param">denMat: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#expectationMat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.expectationMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value of an <cite>operator</cite> for a given <cite>density matrix</cite></p>
<p>Works with both sparse and array.
Operator has to be the matrix (sparse or not), cannot pass a reference to operator function from the toolbox.
State and operator can both be sparse or array or any combination of the two.</p>
<p>:param :
:type : param <cite>operator</cite> : matrix of a Hermitian operator
:param :
:type : param <cite>denMat</cite> : density matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: expectation value of the <cite>operator</cite> for the <cite>density matrix</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.operators</span> <span class="k">as</span> <span class="nn">qOperators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectMat</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">denMat</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">denMat1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">denMat2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.expectationMatList">
<code class="sig-name descname">expectationMatList</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix, denMats: List[Matrix]</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#expectationMatList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.expectationMatList" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value of an <cite>operator</cite> for a given list of <cite>density matrices</cite></p>
<p>Simply calls the <cite>expectationMat</cite> in a loop.
This function exist for easy use in multi-processing.</p>
<p>:param :
:type : param <cite>operator</cite> : matrix of a Hermitian operator
:param :
:type : param <cite>denMats</cite> : list of density matrices</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>list</cite> of expectation values of the <cite>operator</cite> for the list of <cite>density matrices</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMatList</span> <span class="o">=</span> <span class="p">[</span><span class="n">denMat0</span><span class="p">,</span> <span class="n">denMat1</span><span class="p">,</span> <span class="n">denMat2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectMatList</span> <span class="o">=</span> <span class="n">expectationMatList</span><span class="p">(</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">denMats</span><span class="o">=</span><span class="n">denMatList</span><span class="p">)</span>
<span class="go">[-1, 1, 0.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.fidelity">
<code class="sig-name descname">fidelity</code><span class="sig-paren">(</span><em class="sig-param">state1: Matrix</em>, <em class="sig-param">state2: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <cite>fidelity</cite> between <cite>two states</cite></p>
<p>States can either be a <cite>ket</cite> or <cite>density matrix</cite>,
and they can both be sparse or array or any combination of the two.</p>
<p>:param :
:type : param <cite>state1</cite>: <cite>ket</cite> state or <cite>density matrix</cite>
:param :
:type : param <cite>state2</cite> : <cite>ket</cite> state or <cite>density matrix</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>fidelity</cite> between any <cite>two states</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityKet01</span> <span class="o">=</span> <span class="n">fidelity</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">ket0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">ket1</span><span class="p">)</span>
<span class="go">0.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityKet02</span> <span class="o">=</span> <span class="n">fidelity</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">ket0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">ket2</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityKet12</span> <span class="o">=</span> <span class="n">fidelity</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">ket1</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">ket2</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityMat01</span> <span class="o">=</span> <span class="n">fidelity</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">denMat0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">denMat1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityMat02</span> <span class="o">=</span> <span class="n">fidelity</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">denMat0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">denMat2</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityMat12</span> <span class="o">=</span> <span class="n">fidelity</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">denMat1</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">denMat2</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.fidelityKet">
<code class="sig-name descname">fidelityKet</code><span class="sig-paren">(</span><em class="sig-param">ket1: Matrix</em>, <em class="sig-param">ket2: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#fidelityKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.fidelityKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <cite>fidelity</cite> between two <cite>ket</cite> states</p>
<p>States can both be sparse or array or any combination of the two.</p>
<p>:param :
:type : param <cite>ket1</cite> : ket state
:param :
:type : param <cite>ket2</cite> : ket state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>fidelity</cite> between two <cite>ket states</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityKet01</span> <span class="o">=</span> <span class="n">fidelityKet</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">ket0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">ket1</span><span class="p">)</span>
<span class="go">0.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityKet02</span> <span class="o">=</span> <span class="n">fidelityKet</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">ket0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">ket2</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityKet12</span> <span class="o">=</span> <span class="n">fidelityKet</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">ket1</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">ket2</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.fidelityKetList">
<code class="sig-name descname">fidelityKetList</code><span class="sig-paren">(</span><em class="sig-param">ket1: Matrix, ketList: List[Matrix]</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#fidelityKetList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.fidelityKetList" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <cite>fidelity</cite> between <cite>a ket state</cite> and <cite>list of ket states</cite></p>
<p>States can both be sparse or array or any combination of the two.</p>
<p>:param :
:type : param <cite>ket1</cite> : ket state
:param :
:type : param <cite>ketList</cite> : <cite>list</cite> of ket states</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>list</cite> of fidelities between <cite>a ket state</cite> and <cite>list of ket states</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ketList</span> <span class="o">=</span> <span class="p">[</span><span class="n">ket0</span><span class="p">,</span> <span class="n">ket1</span><span class="p">,</span> <span class="n">ket2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityList</span> <span class="o">=</span> <span class="n">fidelityKetList</span><span class="p">(</span><span class="n">ket0</span><span class="p">,</span> <span class="n">ketList</span><span class="p">)</span>
<span class="go">[1, 0, 0.5000000000000001]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.fidelityKetLists">
<code class="sig-name descname">fidelityKetLists</code><span class="sig-paren">(</span><em class="sig-param">zippedStatesList: Any</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#fidelityKetLists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.fidelityKetLists" title="Permalink to this definition">¶</a></dt>
<dd><p>Created to be used in <cite>multi-processing</cite> calculations of two lists of kets states</p>
<p>FIXME too specific, requires zipping</p>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.fidelityPureMat">
<code class="sig-name descname">fidelityPureMat</code><span class="sig-paren">(</span><em class="sig-param">denMat1: Matrix</em>, <em class="sig-param">denMat2: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#fidelityPureMat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.fidelityPureMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <cite>fidelity</cite> between two (pure) <cite>density matrices</cite></p>
<p>States can both be sparse or array or any combination of the two.</p>
<p>:param :
:type : param <cite>denMat1</cite> : (pure) density matrix
:param :
:type : param <cite>denMat2</cite> : (pure) density matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>fidelity</cite> between two (pure) <cite>density matrices</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityMat01</span> <span class="o">=</span> <span class="n">fidelityPureMat</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">denMat0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">denMat1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityMat02</span> <span class="o">=</span> <span class="n">fidelityPureMat</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">denMat0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">denMat2</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityMat12</span> <span class="o">=</span> <span class="n">fidelityPureMat</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">denMat1</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">denMat2</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.iprKet">
<code class="sig-name descname">iprKet</code><span class="sig-paren">(</span><em class="sig-param">basis: List[Matrix], ket: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#iprKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.iprKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse participation ratio (a delocalisation measure) of a <cite>ket</cite> in a given basis</p>
<p>:param :
:type : param <cite>ket</cite> : a ket state
:param :
:type : param <cite>basis</cite> : a complete basis</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: inverse participation ratio</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">completeBasis</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr0</span> <span class="o">=</span> <span class="n">iprKet</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">state0</span><span class="p">)</span>
<span class="go">1.1245136186770428</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr1</span> <span class="o">=</span> <span class="n">iprKet</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">state1</span><span class="p">)</span>
<span class="go">2.000000000000001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr2</span> <span class="o">=</span> <span class="n">iprKet</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">state2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.iprKetList">
<code class="sig-name descname">iprKetList</code><span class="sig-paren">(</span><em class="sig-param">basis: List[Matrix], kets: List[Matrix]</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#iprKetList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.iprKetList" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse participation ratio (a delocalisation measure) of a <cite>list of ket</cite> states in a given basis</p>
<p>Simply calls iprKet in a loop.</p>
<p>:param :
:type : param <cite>kets</cite> : a <cite>list</cite> of ket states
:param :
:type : param <cite>basis</cite> : a complete basis</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: a <cite>list</cite> of inverse participation ratios for the given list of ket states</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">completeBasis</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state3</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stateList</span> <span class="o">=</span> <span class="p">[</span><span class="n">state0</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">,</span> <span class="n">state3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iprList</span> <span class="o">=</span> <span class="n">iprKetList</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">stateList</span><span class="p">)</span>
<span class="go">[1.1245136186770428, 2.000000000000001, 1.0, 1.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.iprKetNB">
<code class="sig-name descname">iprKetNB</code><span class="sig-paren">(</span><em class="sig-param">ket: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#iprKetNB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.iprKetNB" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse participation ratio (a delocalisation measure) of a ket
by assuming that the basis is of the free Hamiltonian</p>
<p>:param :
:type : param <cite>ket</cite> : a ket state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: inverse participation ratio</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr0</span> <span class="o">=</span> <span class="n">iprKetNB</span><span class="p">(</span><span class="n">state0</span><span class="p">)</span>
<span class="go">1.1245136186770428</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr1</span> <span class="o">=</span> <span class="n">iprKetNB</span><span class="p">(</span><span class="n">state1</span><span class="p">)</span>
<span class="go">2.000000000000001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr2</span> <span class="o">=</span> <span class="n">iprKetNB</span><span class="p">(</span><span class="n">state2</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state3</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr3</span> <span class="o">=</span> <span class="n">iprKetNB</span><span class="p">(</span><span class="n">state3</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.iprKetNBList">
<code class="sig-name descname">iprKetNBList</code><span class="sig-paren">(</span><em class="sig-param">kets: List[Matrix]</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#iprKetNBList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.iprKetNBList" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse participation ratio (a delocalisation measure) of a list kets
by assuming that the basis is of the free Hamiltonian</p>
<p>Simply calls iprKetNB in a loop.</p>
<p>:param :
:type : param kets: a <cite>list</cite> of ket states</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: a <cite>list</cite> of inverse participation ratios</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state3</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stateList</span> <span class="o">=</span> <span class="p">[</span><span class="n">state0</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">,</span> <span class="n">state3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iprList</span> <span class="o">=</span> <span class="n">iprKetNBList</span><span class="p">(</span><span class="n">stateList</span><span class="p">)</span>
<span class="go">[1.1245136186770428, 2.000000000000001, 1.0, 1.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.iprKetNBmat">
<code class="sig-name descname">iprKetNBmat</code><span class="sig-paren">(</span><em class="sig-param">kets: numpy.ndarray</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#iprKetNBmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.iprKetNBmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse participation ratio (a delocalisation measure) of <cite>a matrix of ket states as the column</cite></p>
<p>For example the eigenstates obtained from eigenvalue calculations of numpy or scipy are this form.
TODO use if you know what you are doing.
This assumes the basis is of the free Hamiltonian.</p>
<p>:param :
:type : param ket: a density matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: a <cite>list</cite> of inverse participation ratios</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.operators</span> <span class="k">as</span> <span class="nn">qOperators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ham</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigValsHam</span><span class="p">,</span> <span class="n">eigVecsHams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">ham</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iprHam</span> <span class="o">=</span> <span class="n">iprKetNBmat</span><span class="p">(</span><span class="n">eigVecsHams</span><span class="p">)</span>
<span class="go">[1.0, 1.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unitary</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="n">ham</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigValsUni</span><span class="p">,</span> <span class="n">eigVecsUni</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">unitary</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iprUni</span> <span class="o">=</span> <span class="n">iprKetNBmat</span><span class="p">(</span><span class="n">eigVecsUni</span><span class="p">)</span>
<span class="go">[1.0, 1.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.iprPureDenMat">
<code class="sig-name descname">iprPureDenMat</code><span class="sig-paren">(</span><em class="sig-param">basis: List[Matrix], denMat: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#iprPureDenMat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.iprPureDenMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse participation ratio (a delocalisation measure) of a <cite>density matrix</cite> in a given <cite>basis</cite></p>
<p>:param :
:type : param <cite>denMat</cite> : a density matrix
:param :
:type : param <cite>basis</cite> : a complete basis</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: inverse participation ratio</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">completeBasis</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasisMat</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">state0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr0</span> <span class="o">=</span> <span class="n">iprPureDenMat</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">denMat0</span><span class="p">)</span>
<span class="go">1.1245136186770428</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">state1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr1</span> <span class="o">=</span> <span class="n">iprPureDenMat</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">denMat1</span><span class="p">)</span>
<span class="go">2.000000000000001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">state2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr2</span> <span class="o">=</span> <span class="n">iprPureDenMat</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">denMat2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.sortedEigens">
<code class="sig-name descname">sortedEigens</code><span class="sig-paren">(</span><em class="sig-param">Ham: Matrix</em><span class="sig-paren">)</span> &#x2192; Tuple[List[float], List[numpy.ndarray]]<a class="reference internal" href="../../_modules/qTools/QuantumToolbox/functions.html#sortedEigens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.sortedEigens" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the <cite>eigenvalues and eigenvectors</cite> of a given Hamiltonian and <cite>sorts</cite> them</p>
<p>:param :
:type : param <cite>Ham</cite> : the Hamiltonian</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>sorted</cite> eigenvalues and eigenvectors</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.operators</span> <span class="k">as</span> <span class="nn">qOperators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ham</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">Jx</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigVals</span><span class="p">,</span> <span class="n">eigVecs</span> <span class="o">=</span> <span class="n">sortedEigens</span><span class="p">(</span><span class="n">ham</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eigVals</span><span class="p">)</span>
<span class="go">[-2.5+0.j -1.5+0.j -0.5+0.j  0.5+0.j  1.5+0.j  2.5+0.j]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eigVecs</span><span class="p">)</span>
<span class="go">[[ 0.1767767   0.39528471  0.55901699  0.55901699 -0.39528471 -0.1767767 ]</span>
<span class="go">[-0.39528471 -0.53033009 -0.25        0.25       -0.53033009 -0.39528471]</span>
<span class="go">[ 0.55901699  0.25       -0.35355339 -0.35355339 -0.25       -0.55901699]</span>
<span class="go">[-0.55901699  0.25        0.35355339 -0.35355339  0.25       -0.55901699]</span>
<span class="go">[ 0.39528471 -0.53033009  0.25        0.25        0.53033009 -0.39528471]</span>
<span class="go">[-0.1767767   0.39528471 -0.55901699  0.55901699  0.39528471 -0.1767767 ]]</span>
</pre></div>
</div>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../Evolutions/evolutions.html" class="btn btn-neutral float-right" title="Evolutions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../Operators/operators.html" class="btn btn-neutral float-left" title="Operators" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Cahit Kargi
      <span class="lastupdated">
        Last updated on 2020/05/15.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>