from .customTypes import Matrix as Matrix
from .linearAlgebra import tensorProd as tensorProd
from typing import Callable

def number(dimension: int, sparse: bool = ...) -> Matrix: ...
def destroy(dimension: int, sparse: bool = ...) -> Matrix: ...
def create(dimension: int, sparse: bool = ...) -> Matrix: ...
def identity(dimension: int, sparse: bool = ...) -> Matrix: ...
def sigmaz(sparse: bool = ...) -> Matrix: ...
def sigmay(sparse: bool = ...) -> Matrix: ...
def sigmax(sparse: bool = ...) -> Matrix: ...
def sigmap(sparse: bool = ...) -> Matrix: ...
def sigmam(sparse: bool = ...) -> Matrix: ...
def Jp(j: float, sparse: bool = ..., isDim: bool = ...) -> Matrix: ...
def Jm(j: float, sparse: bool = ..., isDim: bool = ...) -> Matrix: ...
def Jx(j: float, sparse: bool = ..., isDim: bool = ...) -> Matrix: ...
def Jy(j: float, sparse: bool = ..., isDim: bool = ...) -> Matrix: ...
def Jz(j: float, sparse: bool = ..., isDim: bool = ...) -> Matrix: ...
def Js(j: float, sparse: bool = ..., isDim: bool = ...) -> Matrix: ...
def displacement(alpha: complex, dim: int, sparse: bool = ...) -> Matrix: ...
def squeeze(alpha: complex, dim: int, sparse: bool = ...) -> Matrix: ...
def parityEXP(HamiltonianCavity: Matrix) -> Matrix: ...
def paritySUM(dimension: int, sparse: bool = ...) -> Matrix: ...
def compositeOp(operator: Matrix, dimB: int = ..., dimA: int = ...) -> Matrix: ...
def operatorPow(op: Callable, dim: int, power: int, sparse: bool = ...) -> Matrix: ...
